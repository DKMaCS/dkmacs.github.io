<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Mean–Variance Optimizer</title>

  <!-- Minimal styling -->
  <style>
    /* --- Global sane defaults --- */
    *, *::before, *::after { box-sizing: border-box; }
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color-scheme: light dark; }
    body { margin: 20px; }
    img, canvas, textarea { max-width: 100%; }
    h1 { margin: 0 0 8px; font-size: 1.5rem; }

    /* --- Layout cards/columns --- */
    .card { border: 1px solid #ccc; border-radius: 12px; padding: 16px; margin: 10px 0; overflow: hidden; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-start; }
    .col { flex: 1 1 340px; min-width: 280px; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .grid2 > * { min-width: 0; }
    @media (max-width:760px){ .grid2{ grid-template-columns: 1fr; } }

    /* --- Typography & helpers --- */
    label { font-weight: 600; display:block; margin: 8px 0 4px; }
    .muted { opacity: 0.8; font-size: 0.92rem; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#eee; margin-left:6px; font-size:0.8rem; }
    .inline { display:inline-flex; gap:8px; align-items:center; }
    .warn { color:#a33; font-weight:600; }
    .success { color:#2a7; font-weight:600; }
    .right { text-align:right; }
    .footer { margin-top: 16px; font-size: 0.9rem; }
    .chips { display:flex; gap:8px; flex-wrap:wrap; }
    .chip { border:1px solid #ddd; border-radius:999px; padding:4px 10px; font-size:.85rem; }

    /* --- Form controls (fix overflow) --- */
    input, select, textarea { width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #bbb; }
    button { padding: 8px; border-radius: 8px; border: 1px solid #bbb; cursor: pointer; }
    .card .row button { width: auto; flex: 1 1 0; min-width: 140px; }

    textarea { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre; overflow: auto; }
  </style>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.1/lib/browser/math.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
  <h1>Mean–Variance Optimizer <span class="pill">client-side</span></h1>
  <p class="muted">Upload a CSV of prices, pick settings, and get the efficient frontier, the Capital Market Line (CML), the tangency portfolio, and optimal weights for your chosen risk-aversion (γ). Nothing leaves your browser.</p>

  <div class="row">
    <div class="col">
      <div class="card">
        <label>Upload Prices CSV</label>
        <input id="fileInput" type="file" accept=".csv"/>
        <p class="muted">Format: first column = <em>Date</em>, subsequent columns = asset tickers (Adjusted Close). Example snippet:</p>
        <textarea rows="6" readonly>
Date,SPY,IEF,GLD
2024-01-02,474.35,94.85,190.92
2024-01-03,469.63,95.17,191.41
2024-01-04,472.28,95.24,192.19
        </textarea>

        <div class="grid2">
          <div>
            <label>Return Frequency</label>
            <select id="freq">
              <option value="252" selected>Daily (252 per year)</option>
              <option value="52">Weekly (52 per year)</option>
              <option value="12">Monthly (12 per year)</option>
            </select>
          </div>
          <div>
            <label>Risk-Free Rate (annualized, e.g. 0.02 = 2%)</label>
            <input id="rf" type="number" step="0.0001" value="0"/>
          </div>
        </div>

        <div class="grid2" style="margin-top:8px;">
          <div>
            <label>Risk-Aversion γ (higher = more risk-averse)</label>
            <input id="gamma" type="number" step="0.1" value="3"/>
          </div>
          <div>
            <label>Frontier Points</label>
            <input id="nFrontier" type="number" step="10" value="60"/>
          </div>
        </div>

        <div class="chips" style="margin-top:10px;">
          <span class="chip">Shorting allowed (exact closed-form)</span>
          <span class="chip">Constraint: 1ᵀw = 1</span>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="btnCompute">Compute Frontier & Weights</button>
          <button id="btnDownload" disabled>Download Weights CSV</button>
        </div>
        <p id="status" class="muted" style="margin-top:8px;"></p>
      </div>
    </div>

    <div class="col">
      <div class="card">
        <label>Efficient Frontier + CML</label>
        <canvas id="frontierChart" height="280"></canvas>
        <div class="footer">
          <span id="pfStats" class="muted"></span><br/>
          <span id="tanStats" class="muted"></span>
        </div>
      </div>

      <div class="card">
        <label>Optimal Weights (for chosen γ)</label>
        <div style="overflow:auto; max-height:260px;">
          <table id="weightsTable">
            <thead><tr><th>Asset</th><th>Weight</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
        <p class="muted">Models: MVO (shorting allowed). Tangency portfolio uses Σ⁻¹(μ−r_f·1) normalized to sum to 1. CML runs from (σ=0, μ=r_f) to the tangency point.</p>
      </div>
    </div>
  </div>

  <div class="card">
    <strong>Notes & Tips</strong>
    <ul>
      <li><b>Data:</b> Use adjusted close prices. The app computes log returns.</li>
      <li><b>Annualization:</b> Means & covariances scale by your selected frequency (252/52/12).</li>
      <li><b>Long-only?</b> This version is exact for <em>shorting allowed</em>. For non-negative weights you’ll need a QP step.</li>
    </ul>
  </div>

<script>
/* === Utilities === */
const $ = sel => document.querySelector(sel);
const statusEl = $('#status');
let chart;

/* CSV -> matrix helpers */
function parseCSVToMatrix(csv) {
  const parsed = Papa.parse(csv.trim(), { header: true, dynamicTyping: true });
  if (parsed.errors.length) throw new Error(parsed.errors[0].message);
  const rows = parsed.data.filter(r => r && Object.values(r).some(v => v !== null && v !== ''));
  if (!rows.length) throw new Error('No data rows found');

  const headers = parsed.meta.fields;
  if (!headers || headers.length < 2) throw new Error('Need Date + at least one asset column');

  const tickers = headers.slice(1);
  const prices = rows.map(r => tickers.map(k => Number(r[k])));
  for (let i=0;i<prices.length;i++){
    for (let j=0;j<prices[0].length;j++){
      if (!isFinite(prices[i][j])) throw new Error(`Bad value at row ${i+2}, col ${tickers[j]}`);
    }
  }
  return { tickers, prices };
}

function toReturns(prices, useLog=true) {
  const T = prices.length;
  const N = prices[0].length;
  const R = [];
  for (let t=1;t<T;t++){
    const row = new Array(N);
    for (let i=0;i<N;i++){
      const r = prices[t][i] / prices[t-1][i];
      row[i] = useLog ? Math.log(r) : (r - 1);
    }
    R.push(row);
  }
  return R; // (T-1) x N
}

function mean(vec) { return vec.reduce((a,b)=>a+b,0)/vec.length; }
function column(matrix, j) { return matrix.map(row => row[j]); }

function covarianceMatrix(R) {
  const T = R.length, N = R[0].length;
  const means = Array.from({length:N}, (_,j)=> mean(column(R,j)));
  const S = math.zeros(N, N)._data;
  for (let i=0;i<N;i++){
    for (let j=0;j<N;j++){
      let s=0;
      for (let t=0;t<T;t++) s += (R[t][i]-means[i])*(R[t][j]-means[j]);
      S[i][j] = s/(T-1);
    }
  }
  return { cov: S, mean: means };
}

function scaleAnnual(mu, Sigma, freq) {
  const muA = mu.map(m => m * freq);
  const sigA = math.multiply(Sigma, freq); // covariance scales linearly
  return { muA, sigA };
}

/* === MVO Closed-Form (shorting allowed, 1ᵀw=1) === */
function optimalWeightsGivenGamma(mu, Sigma, gamma) {
  const N = mu.length;
  const I = math.ones(N)._data;
  const invS = math.inv(Sigma);
  const invS_mu = math.multiply(invS, mu);
  const invS_1  = math.multiply(invS, I);
  const A = math.multiply(math.transpose(I), invS_1);
  const B = math.multiply(math.transpose(I), invS_mu);
  const term1 = math.multiply(1/gamma, invS_mu);
  const term2 = math.multiply((gamma - B)/(gamma * A), invS_1);
  const w = math.add(term1, term2);
  return w.map(x => Math.abs(x) < 1e-12 ? 0 : x);
}

/* === Efficient Frontier (equality-constrained) === */
function efficientFrontier(mu, Sigma, nPoints=60, margin=0.15) {
  const N = mu.length;
  const I = math.ones(N)._data;
  const invS = math.inv(Sigma);
  const A = math.multiply(math.transpose(I), math.multiply(invS, I));
  const B = math.multiply(math.transpose(I), math.multiply(invS, mu));
  const C = math.multiply(math.transpose(mu), math.multiply(invS, mu));
  const D = A*C - B*B;
  if (D <= 0) throw new Error('Non-PD covariance or collinearity: D ≤ 0');

  const muMin = Math.min(...mu);
  const muMax = Math.max(...mu);
  const span  = muMax - muMin || Math.max(Math.abs(muMax), 1e-3);
  const rLo = muMin - margin*span, rHi = muMax + margin*span;

  const pts = [];
  for (let k=0;k<nPoints;k++){
    const r = rLo + (rHi - rLo)*k/(nPoints-1);
    const alpha = (C - B*r)/D;
    const beta  = (A*r - B)/D;
    const w = math.multiply(invS, math.add(math.multiply(alpha, I), math.multiply(beta, mu)));
    const var_ = (A*r*r - 2*B*r + C)/D;
    pts.push({ r, s: Math.sqrt(Math.max(var_, 0)), w });
  }
  return pts;
}

/* === Stats === */
function portfolioStats(w, mu, Sigma) {
  const ret = math.multiply(math.transpose(w), mu);
  const var_ = math.multiply(math.transpose(w), math.multiply(Sigma, w));
  return { ret, vol: Math.sqrt(Math.max(var_, 0)) };
}

/* === Tangency (max Sharpe) and CML ===
   Tangency weights (sum to 1): w_T = Σ^{-1}(μ - r_f 1) / (1ᵀΣ^{-1}(μ - r_f 1))
*/
function tangencyPortfolio(mu, Sigma, rf) {
  const N = mu.length;
  const I = math.ones(N)._data;
  const invS = math.inv(Sigma);
  const muEx = math.subtract(mu, math.multiply(rf, I));        // μ - r_f 1
  const num  = math.multiply(invS, muEx);                       // Σ^{-1}(μ - r_f 1)
  const den  = math.multiply(math.transpose(I), num);           // 1ᵀΣ^{-1}(μ - r_f 1)
  const wT   = math.divide(num, den);                           // normalize to sum to 1
  const { ret, vol } = portfolioStats(wT, mu, Sigma);
  const sharpe = (ret - rf) / Math.max(vol, 1e-12);
  return { wT, ret, vol, sharpe };
}

function makeCMLPoints(rf, tanVol, tanRet, xMax, n=50) {
  const slope = (tanRet - rf) / Math.max(tanVol, 1e-12);
  const pts = [];
  for (let i=0;i<n;i++){
    const x = (xMax * i)/(n-1);            // σ from 0 to xMax
    const y = rf + slope * x;              // μ on the CML
    pts.push({ x, y });
  }
  return pts;
}

/* === UI wiring === */
let lastWeights = null;

$('#btnCompute').addEventListener('click', async () => {
  try {
    statusEl.textContent = 'Parsing & computing…';
    const file = $('#fileInput').files[0];
    if (!file) throw new Error('Please choose a CSV file.');
    const text = await file.text();

    const freq = Number($('#freq').value);
    const rf = Number($('#rf').value) || 0;
    const gamma = Number($('#gamma').value);
    const nFrontier = Math.max(10, Number($('#nFrontier').value));

    const { tickers, prices } = parseCSVToMatrix(text);
    if (prices.length < 3) throw new Error('Need at least 3 rows of prices.');
    const R = toReturns(prices, true); // log returns
    const { cov, mean: m } = covarianceMatrix(R);
    const { muA, sigA } = scaleAnnual(m, cov, freq);

    // Frontier (uses total μ)
    const frontPts = efficientFrontier(muA, sigA, nFrontier);

    // Tangency + CML
    const { wT, ret: tanRet, vol: tanVol, sharpe: tanSharpe } = tangencyPortfolio(muA, sigA, rf);
    const maxSigma = Math.max(tanVol, ...frontPts.map(p => p.s)) * 1.05;
    const cmlPts = makeCMLPoints(rf, tanVol, tanRet, maxSigma, 80);

    // Optimal weights for chosen γ (utility uses μ - r_f but constraint uses Σ)
    const muExcess = muA.map(u => u - rf);
    const wStar = optimalWeightsGivenGamma(muExcess, sigA, gamma);

    // Display weights (for γ)
    const tbody = $('#weightsTable tbody');
    tbody.innerHTML = '';
    lastWeights = [];
    for (let i=0;i<tickers.length;i++){
      const tr = document.createElement('tr');
      const wt = wStar[i];
      lastWeights.push({ Asset: tickers[i], Weight: wt });
      tr.innerHTML = `<td>${tickers[i]}</td><td>${(wt*100).toFixed(2)}%</td>`;
      tbody.appendChild(tr);
    }
    $('#btnDownload').disabled = false;

    // Stats
    const stats = portfolioStats(wStar, muA, sigA);
    $('#pfStats').textContent =
      `Optimal (γ=${gamma}):  E[μ]=${(stats.ret*100).toFixed(2)}%  |  σ=${(stats.vol*100).toFixed(2)}%  |  Sharpe≈${((stats.ret - rf)/Math.max(stats.vol,1e-9)).toFixed(2)}`;
    $('#tanStats').textContent =
      `Tangency:  E[μ]=${(tanRet*100).toFixed(2)}%  |  σ=${(tanVol*100).toFixed(2)}%  |  Sharpe=${tanSharpe.toFixed(2)}  |  rf=${(rf*100).toFixed(2)}%`;

    // Plot (frontier + CML + points)
    const data = {
      labels: frontPts.map(_=> ''),
      datasets: [
        {
          label: 'Efficient Frontier',
          data: frontPts.map(p => ({ x: p.s, y: p.r })),
          showLine: true,
          pointRadius: 2
        },
        {
          label: 'CML (through Tangency)',
          data: cmlPts,
          showLine: true,
          pointRadius: 0,
          borderDash: [6,4]
        },
        {
          label: 'Tangency Portfolio',
          data: [{ x: tanVol, y: tanRet }],
          pointRadius: 5
        },
        {
          label: 'Your Portfolio (γ)',
          data: [{ x: stats.vol, y: stats.ret }],
          pointRadius: 5
        }
      ]
    };
    const ctx = document.getElementById('frontierChart');
    if (chart) chart.destroy();
    chart = new Chart(ctx, {
      type: 'scatter',
      data,
      options: {
        animation: false,
        responsive: true,
        plugins: {
          legend: { position: 'top' },
          tooltip: {
            callbacks: {
              label: function(ctx){
                const x = ctx.raw.x, y = ctx.raw.y;
                return `σ=${(x*100).toFixed(2)}%, μ=${(y*100).toFixed(2)}%`;
              }
            }
          }
        },
        scales: {
          x: { title: { display: true, text: 'Volatility (σ, annualized)' } },
          y: { title: { display: true, text: 'Expected Return (μ, annualized)' } }
        }
      }
    });

    statusEl.innerHTML = `<span class="success">Done.</span> Loaded ${prices.length} rows × ${tickers.length} assets.`;
  } catch (e) {
    statusEl.innerHTML = `<span class="warn">Error:</span> ${e.message}`;
    console.error(e);
  }
});

$('#btnDownload').addEventListener('click', () => {
  if (!lastWeights) return;
  const rows = ['Asset,Weight'].concat(lastWeights.map(r => `${r.Asset},${r.Weight}`));
  const blob = new Blob([rows.join('\n')], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'weights.csv'; a.click();
  URL.revokeObjectURL(url);
});
</script>
</body>
</html>
