<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Mean–Variance Optimizer</title>

    <style>
      *, *::before, *::after { box-sizing: border-box; }
      :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color-scheme: light dark; }
      body { margin: 20px; }
      img, canvas, textarea { max-width: 100%; }
      h1 { margin: 0 0 8px; font-size: 1.5rem; }
      .card { border: 1px solid #ccc; border-radius: 12px; padding: 16px; margin: 10px 0; overflow: hidden; }
      .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-start; }
      .col { flex: 1 1 340px; min-width: 280px; }
      .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
      .grid2 > * { min-width: 0; }
      @media (max-width:760px){ .grid2{ grid-template-columns: 1fr; } }
      label { font-weight: 600; display:block; margin: 8px 0 4px; }
      .muted { opacity: 0.8; font-size: 0.92rem; }
      .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#eee; margin-left:6px; font-size:0.8rem; }
      .inline { display:inline-flex; gap:8px; align-items:center; }
      .warn { color:#a33; font-weight:600; }
      .success { color:#2a7; font-weight:600; }
      .right { text-align:right; }
      .footer { margin-top: 16px; font-size: 0.9rem; }
      .chips { display:flex; gap:8px; flex-wrap:wrap; }
      .chip { border:1px solid #ddd; border-radius:999px; padding:4px 10px; font-size:.85rem; }
      input, select, textarea { width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #bbb; }
      button { padding: 8px; border-radius: 8px; border: 1px solid #bbb; cursor: pointer; }
      .card .row button { width: auto; flex: 1 1 0; min-width: 140px; }
      textarea { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre; overflow: auto; }

      /* --- FIX: keep checkbox + text together --- */
      .toggle { display: inline-flex; align-items: center; gap: 8px; margin-top: 8px; white-space: nowrap; }
      .toggle input { margin: 0; }

    </style>


  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.1/lib/browser/math.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
  <h1>Mean–Variance Optimizer</h1>
  <p class="muted">Upload a CSV of prices, pick settings, and get the efficient frontier, CML, tangency, and γ-portfolio. Nothing leaves your browser.</p>

  <div class="row">
    <div class="col">
      <div class="card">
        <label>Upload Prices CSV</label>
        <input id="fileInput" type="file" accept=".csv"/>
        <p class="muted">Format: first column = <em>Date</em>, subsequent columns = asset tickers (Adjusted Close). Example snippet:</p>
        <textarea rows="6" readonly>
Date,SPY,IEF,GLD
2024-01-02,474.35,94.85,190.92
2024-01-03,469.63,95.17,191.41
2024-01-04,472.28,95.24,192.19
        </textarea>

        <div class="grid2">
          <div>
            <label>Return Frequency</label>
            <select id="freq">
              <option value="252" selected>Daily (252 per year)</option>
              <option value="52">Weekly (52 per year)</option>
              <option value="12">Monthly (12 per year)</option>
            </select>
          </div>
          <div>
            <label>Risk-Free Rate (annualized, e.g. 0.02 = 2%)</label>
            <input id="rf" type="number" step="0.0001" value="0.02"/>
          </div>
        </div>

        <div class="grid2" style="margin-top:8px;">
          <div>
            <label>Risk-Aversion γ (higher = more risk-averse)</label>
            <input id="gamma" type="number" step="0.1" value="3"/>
          </div>
          <div>
            <label>Frontier Points</label>
            <input id="nFrontier" type="number" step="10" value="120"/>
          </div>
        </div>

        <div class="toggle">
            <label class="toggle">
              <input id="longOnly" type="checkbox">
              Long-only (no shorting)
            </label>
        </div>

        <div class="chips" style="margin-top:10px;">
          <span class="chip">If unchecked: shorting allowed (closed-form)</span>
          <span class="chip">Constraint: 1ᵀw = 1</span>
        </div>

        <div class="row" style="margin-top:10px; gap:8px;">
          <button id="btnCompute">Compute Frontier & Weights</button>
          <button id="btnDownloadGamma"  disabled>Download Gamma</button>
          <button id="btnDownloadTan"    disabled>Download Tangency</button>
          <button id="btnDownloadMVP"    disabled>Download MVP</button>
        </div>
        <p id="status" class="muted" style="margin-top:8px;"></p>
      </div>
    </div>

    <div class="col">
      <div class="card">
        <label>Efficient Frontier + CML</label>
        <canvas id="frontierChart" height="280"></canvas>
        <div class="footer">
          <span id="pfStats" class="muted"></span><br/>
          <span id="tanStats" class="muted"></span>
        </div>
      </div>

      <div class="card">
        <label>Optimal Weights (for chosen γ)</label>
        <div style="overflow:auto; max-height:260px;">
          <table id="weightsTable">
            <thead><tr><th>Asset</th><th>Weight</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
        <p class="muted">Long-only uses simplex projection (w ≥ 0, 1ᵀw=1). Exact long-only MVO requires a QP solver.</p>
      </div>
    </div>
  </div>

  <div class="card">
    <strong>Notes & Tips</strong>
    <ul>
      <li><b>Data:</b> Use adjusted close prices. The app computes log returns.</li>
      <li><b>Annualization:</b> Means & covariances scale by your selected frequency (252/52/12).</li>
    </ul>
  </div>

<script>
/* === Utilities === */
const $ = sel => document.querySelector(sel);
const statusEl = $('#status');
let chart;

/* CSV -> matrix helpers */
function parseCSVToMatrix(csv) {
  const parsed = Papa.parse(csv.trim(), { header: true, dynamicTyping: true });
  if (parsed.errors.length) throw new Error(parsed.errors[0].message);
  const rows = parsed.data.filter(r => r && Object.values(r).some(v => v !== null && v !== ''));
  if (!rows.length) throw new Error('No data rows found');

  const headers = parsed.meta.fields;
  if (!headers || headers.length < 2) throw new Error('Need Date + at least one asset column');

  const tickers = headers.slice(1);
  const prices = rows.map(r => tickers.map(k => Number(r[k])));
  for (let i=0;i<prices.length;i++){
    for (let j=0;j<prices[0].length;j++){
      if (!isFinite(prices[i][j])) throw new Error(`Bad value at row ${i+2}, col ${tickers[j]}`);
    }
  }
  return { tickers, prices };
}

function toReturns(prices, useLog=true) {
  const T = prices.length;
  const N = prices[0].length;
  const R = [];
  for (let t=1;t<T;t++){
    const row = new Array(N);
    for (let i=0;i<N;i++){
      const r = prices[t][i] / prices[t-1][i];
      row[i] = useLog ? Math.log(r) : (r - 1);
    }
    R.push(row);
  }
  return R; // (T-1) x N
}

function mean(vec) { return vec.reduce((a,b)=>a+b,0)/vec.length; }
function column(matrix, j) { return matrix.map(row => row[j]); }

function covarianceMatrix(R) {
  const T = R.length, N = R[0].length;
  const means = Array.from({length:N}, (_,j)=> mean(column(R,j)));
  const S = math.zeros(N, N)._data;
  for (let i=0;i<N;i++){
    for (let j=0;j<N;j++){
      let s=0;
      for (let t=0;t<T;t++) s += (R[t][i]-means[i])*(R[t][j]-means[j]);
      S[i][j] = s/(T-1);
    }
  }
  return { cov: S, mean: means };
}

function scaleAnnual(mu, Sigma, freq) {
  const muA = mu.map(m => m * freq);
  const sigA = math.multiply(Sigma, freq); // covariance scales linearly
  return { muA, sigA };
}

/* Helpers */
function toArray1D(x) {
  if (Array.isArray(x)) return x.flat();
  if (x && typeof x.toArray === 'function') return x.toArray().flat();
  return [x];
}

/* === Simplex projection: project v onto {w: w>=0, sum(w)=1} (Duchi et al. 2008) === */
function projectSimplex(v) {
  const n = v.length;
  const u = [...v].sort((a,b)=>b-a);
  let css = 0, rho = -1, theta = 0;
  for (let i=0;i<n;i++){
    css += u[i];
    const t = (css - 1)/(i+1);
    if (u[i] - t > 0) { rho = i; theta = t; }
  }
  theta = (u.slice(0, rho+1).reduce((a,b)=>a+b,0) - 1)/(rho+1);
  const w = v.map(vi => Math.max(vi - theta, 0));
  return w;
}

/* Optionally: project AND renormalize (defensive) */
function enforceLongOnly(w){
  const p = projectSimplex(w);
  // numerical guard to ensure exact sum=1
  const s = p.reduce((a,b)=>a+b,0);
  return s>0 ? p.map(x => x/s) : p;
}

/* === Closed-form weights (shorting allowed, 1ᵀw=1) === */
function optimalWeightsGivenGamma(muExcess, Sigma, gamma) {
  const N = muExcess.length;
  const I = math.ones(N)._data;
  const invS = math.inv(Sigma);
  const invS_mu = math.multiply(invS, muExcess);
  const invS_1  = math.multiply(invS, I);
  const A = math.multiply(math.transpose(I), invS_1);
  const B = math.multiply(math.transpose(I), invS_mu);
  const term1 = math.multiply(1/gamma, invS_mu);
  const term2 = math.multiply((gamma - B)/(gamma * A), invS_1);
  const w = math.add(term1, term2);
  return toArray1D(w);
}

/* MVP (unconstrained) then projected if long-only is set */
function mvpWeights(Sigma) {
  const N = Sigma.length;
  const I = math.ones(N)._data;
  const invS = math.inv(Sigma);
  const invS1 = math.multiply(invS, I);
  const A = math.multiply(math.transpose(I), invS1);
  const w = math.divide(invS1, A);
  return toArray1D(w);
}

/* Efficient Frontier (unconstrained) then optionally projected */
function efficientFrontier(mu, Sigma, nPoints=120, opts={}) {
  const { includeMu = [], margin = 0.35, longOnly = false } = opts;
  const N = mu.length;
  const I = math.ones(N)._data;
  const invS = math.inv(Sigma);
  const A = math.multiply(math.transpose(I), math.multiply(invS, I));
  const B = math.multiply(math.transpose(I), math.multiply(invS, mu));
  const C = math.multiply(math.transpose(mu), math.multiply(invS, mu));
  const D = A*C - B*B;
  if (D <= 0) throw new Error('Non-PD covariance or collinearity: D ≤ 0');

  const mu_mvp = B / A;
  const rawMin = Math.min(...mu);
  const rawMax = Math.max(...mu);
  let rLo = Math.min(mu_mvp, rawMin);
  let rHi = Math.max(rawMax, ...includeMu);
  const spanUp = Math.max(rHi - mu_mvp, 1e-6);
  const spanDn = Math.max(mu_mvp - rLo, 1e-6);
  rHi = rHi + margin * spanUp;
  rLo = rLo - margin * spanDn;

  const pts = [];
  for (let k=0;k<nPoints;k++){
    const r = rLo + (rHi - rLo)*k/(nPoints-1);
    const alpha = (C - B*r)/D;
    const beta  = (A*r - B)/D;
    let w = math.multiply(invS, math.add(math.multiply(alpha, I), math.multiply(beta, mu)));
    w = toArray1D(w);
    if (longOnly) w = enforceLongOnly(w);
    const var_ = math.multiply(math.transpose(w), math.multiply(Sigma, w));
    const ret  = math.multiply(math.transpose(w), mu);
    pts.push({ r: Number(ret), s: Math.sqrt(Math.max(Number(var_), 0)), w });
  }
  return pts;
}

/* Stats */
function portfolioStats(w, mu, Sigma) {
  const wv = math.matrix(w);
  const ret = math.multiply(math.transpose(wv), mu);
  const var_ = math.multiply(math.transpose(wv), math.multiply(Sigma, wv));
  return { ret: Number(ret), vol: Math.sqrt(Math.max(Number(var_), 0)) };
}

/* Tangency (max Sharpe), then optionally projected */
function tangencyPortfolio(mu, Sigma, rf, longOnly=false) {
  const N = mu.length;
  const I = math.ones(N)._data;
  const invS = math.inv(Sigma);
  const muEx = math.subtract(mu, math.multiply(rf, I));        // μ - r_f 1
  let num  = math.multiply(invS, muEx);                         // Σ^{-1}(μ - r_f 1)
  let den  = math.multiply(math.transpose(I), num);             // 1ᵀΣ^{-1}(μ - r_f 1)
  let wT   = toArray1D(math.divide(num, den));                  // sum to 1 (unconstrained)
  if (longOnly) wT = enforceLongOnly(wT);                       // project to long-only
  const { ret, vol } = portfolioStats(wT, mu, Sigma);
  const sharpe = (ret - rf) / Math.max(vol, 1e-12);
  return { wT, ret, vol, sharpe };
}

/* CML points (visual) */
function makeCMLPoints(rf, tanVol, tanRet, xMax, n=100) {
  const slope = (tanRet - rf) / Math.max(tanVol, 1e-12);
  const pts = [];
  for (let i=0;i<n;i++){
    const x = (xMax * i)/(n-1);
    const y = rf + slope * x;
    pts.push({ x, y });
  }
  return pts;
}

/* === UI wiring === */
let weightsGamma = null, weightsTan = null, weightsMVP = null;

$('#btnCompute').addEventListener('click', async () => {
  try {
    statusEl.textContent = 'Parsing & computing…';
    const file = $('#fileInput').files[0];
    if (!file) throw new Error('Please choose a CSV file.');
    const text = await file.text();

    const freq = Number($('#freq').value);
    const rf = Number($('#rf').value) || 0;
    const gamma = Number($('#gamma').value);
    const nFrontier = Math.max(20, Number($('#nFrontier').value));
    const longOnly = $('#longOnly').checked;

    const { tickers, prices } = parseCSVToMatrix(text);
    if (prices.length < 3) throw new Error('Need at least 3 rows of prices.');
    const R = toReturns(prices, true); // log returns
    const { cov, mean: m } = covarianceMatrix(R);
    const { muA, sigA } = scaleAnnual(m, cov, freq);

    // === Gamma (uses μ - r_f), then enforce long-only if requested ===
    const muExcess = muA.map(u => u - rf);
    let wG = optimalWeightsGivenGamma(muExcess, sigA, gamma);
    if (longOnly) wG = enforceLongOnly(wG);
    const statsG = portfolioStats(wG, muA, sigA);

    // === Tangency ===
    const { wT, ret: tanRet, vol: tanVol, sharpe: tanSharpe } =
      tangencyPortfolio(muA, sigA, rf, longOnly);

    // === MVP ===
    let wM = mvpWeights(sigA);
    if (longOnly) wM = enforceLongOnly(wM);

    // === Frontier (ensure it covers γ and Tangency returns) ===
    const frontPts = efficientFrontier(muA, sigA, nFrontier,
      { includeMu: [statsG.ret, tanRet], margin: 0.35, longOnly });

    // === CML (visual only) ===
    const maxSigma = Math.max(tanVol, statsG.vol, ...frontPts.map(p => p.s)) * 1.05;
    const cmlPts = makeCMLPoints(rf, tanVol, tanRet, maxSigma, 100);

    // Save for downloads (show long-only feasible weights)
    weightsGamma = tickers.map((t,i) => ({ Asset: t, Weight: wG[i] }));
    weightsTan   = tickers.map((t,i) => ({ Asset: t, Weight: wT[i] }));
    weightsMVP   = tickers.map((t,i) => ({ Asset: t, Weight: wM[i] }));

    // Table: γ-weights
    const tbody = $('#weightsTable tbody');
    tbody.innerHTML = '';
    for (let i=0;i<tickers.length;i++){
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${tickers[i]}</td><td>${(wG[i]*100).toFixed(2)}%</td>`;
      tbody.appendChild(tr);
    }

    // Enable download buttons
    $('#btnDownloadGamma').disabled = false;
    $('#btnDownloadTan').disabled   = false;
    $('#btnDownloadMVP').disabled   = false;

    // Stats text
    $('#pfStats').textContent =
      `Optimal (γ=${gamma}${longOnly? ", long-only":""}):  E[μ]=${(statsG.ret*100).toFixed(2)}%  |  σ=${(statsG.vol*100).toFixed(2)}%  |  Sharpe≈${((statsG.ret - rf)/Math.max(statsG.vol,1e-9)).toFixed(2)}`;
    $('#tanStats').textContent =
      `Tangency${longOnly? " (projected long-only)":""}:  E[μ]=${(tanRet*100).toFixed(2)}%  |  σ=${(tanVol*100).toFixed(2)}%  |  Sharpe=${tanSharpe.toFixed(2)}  |  rf=${(rf*100).toFixed(2)}%`;

    // Plot
    const data = {
      labels: frontPts.map(_=> ''),
      datasets: [
        { label: 'Efficient Frontier', data: frontPts.map(p => ({ x: p.s, y: p.r })), showLine: true, pointRadius: 2 },
        { label: 'CML (through Tangency)', data: cmlPts, showLine: true, pointRadius: 0, borderDash: [6,4] },
        { label: 'Tangency Portfolio', data: [{ x: tanVol, y: tanRet }], pointRadius: 6 },
        { label: 'Your Portfolio (γ)', data: [{ x: statsG.vol, y: statsG.ret }], pointRadius: 6 }
      ]
    };
    const ctx = document.getElementById('frontierChart');
    if (chart) chart.destroy();
    chart = new Chart(ctx, {
      type: 'scatter',
      data,
      options: {
        animation: false,
        responsive: true,
        plugins: {
          legend: { position: 'top' },
          tooltip: {
            callbacks: {
              label: function(ctx){
                const x = ctx.raw.x, y = ctx.raw.y;
                return `σ=${(x*100).toFixed(2)}%, μ=${(y*100).toFixed(2)}%`;
              }
            }
          }
        },
        scales: {
          x: { title: { display: true, text: 'Volatility (σ, annualized)' } },
          y: { title: { display: true, text: 'Expected Return (μ, annualized)' } }
        }
      }
    });

    statusEl.innerHTML = `<span class="success">Done.</span> Loaded ${prices.length} rows × ${tickers.length} assets.`;
  } catch (e) {
    statusEl.innerHTML = `<span class="warn">Error:</span> ${e.message}`;
    console.error(e);
  }
});

/* CSV download helper */
function downloadCSV(rows, filename) {
  const header = 'Asset,Weight';
  const body   = rows.map(r => `${r.Asset},${r.Weight}`);
  const blob   = new Blob([[header, ...body].join('\n')], { type: 'text/csv;charset=utf-8;' });
  const url    = URL.createObjectURL(blob);
  const a      = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}

/* Three download buttons */
document.getElementById('btnDownloadGamma').addEventListener('click', () => {
  if (!weightsGamma) return;
  downloadCSV(weightsGamma, 'weights_gamma.csv');
});
document.getElementById('btnDownloadTan').addEventListener('click', () => {
  if (!weightsTan) return;
  downloadCSV(weightsTan, 'weights_tangency.csv');
});
document.getElementById('btnDownloadMVP').addEventListener('click', () => {
  if (!weightsMVP) return;
  downloadCSV(weightsMVP, 'weights_mvp.csv');
});
</script>
</body>
</html>
