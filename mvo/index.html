<script>
/* === Utilities === */
const $ = sel => document.querySelector(sel);
const statusEl = $('#status');
let chart;

/* CSV -> matrix helpers */
function parseCSVToMatrix(csv) {
  const parsed = Papa.parse(csv.trim(), { header: true, dynamicTyping: true });
  if (parsed.errors.length) throw new Error(parsed.errors[0].message);
  const rows = parsed.data.filter(r => r && Object.values(r).some(v => v !== null && v !== ''));
  if (!rows.length) throw new Error('No data rows found');
  const headers = parsed.meta.fields;
  if (!headers || headers.length < 2) throw new Error('Need Date + at least one asset column');
  const tickers = headers.slice(1);
  const prices = rows.map(r => tickers.map(k => Number(r[k])));
  for (let i=0;i<prices.length;i++){
    for (let j=0;j<prices[0].length;j++){
      if (!isFinite(prices[i][j])) throw new Error(`Bad value at row ${i+2}, col ${tickers[j]}`);
    }
  }
  return { tickers, prices };
}

function toReturns(prices, useLog=true) {
  const T = prices.length, N = prices[0].length;
  const R = [];
  for (let t=1;t<T;t++){
    const row = new Array(N);
    for (let i=0;i<N;i++){
      const r = prices[t][i] / prices[t-1][i];
      row[i] = useLog ? Math.log(r) : (r - 1);
    }
    R.push(row);
  }
  return R; // (T-1) x N
}

function mean(vec) { return vec.reduce((a,b)=>a+b,0)/vec.length; }
function column(matrix, j) { return matrix.map(row => row[j]); }

function covarianceMatrix(R) {
  const T = R.length, N = R[0].length;
  const means = Array.from({length:N}, (_,j)=> mean(column(R,j)));
  const S = math.zeros(N, N)._data;
  for (let i=0;i<N;i++){
    for (let j=0;j<N;j++){
      let s=0;
      for (let t=0;t<T;t++) s += (R[t][i]-means[i])*(R[t][j]-means[j]);
      S[i][j] = s/(T-1);
    }
  }
  return { cov: S, mean: means };
}

function scaleAnnual(mu, Sigma, freq) {
  const muA = mu.map(m => m * freq);
  const sigA = math.multiply(Sigma, freq); // covariance scales linearly
  return { muA, sigA };
}

function toArray1D(x) { if (Array.isArray(x)) return x.flat(); if (x && typeof x.toArray === 'function') return x.toArray().flat(); return [x]; }

/* === Simplex projection (Duchi et al., 2008) === */
function projectSimplex(v) {
  const n = v.length;
  const u = [...v].sort((a,b)=>b-a);
  let css = 0, rho = -1, theta = 0;
  for (let i=0;i<n;i++){
    css += u[i];
    const t = (css - 1)/(i+1);
    if (u[i] - t > 0) { rho = i; theta = t; }
  }
  theta = (u.slice(0, rho+1).reduce((a,b)=>a+b,0) - 1)/(rho+1);
  const w = v.map(vi => Math.max(vi - theta, 0));
  // exact sum=1 guard
  const s = w.reduce((a,b)=>a+b,0);
  return s>0 ? w.map(x=>x/s) : w;
}

/* ============ NEW: True constrained QP on simplex (APGD) ============ */
/* Solve: minimize 0.5 w^T H w - b^T w  s.t. w ∈ Δ = {w >= 0, 1^T w = 1} */
function qpOnSimplex(H, b, maxIter=5000, tol=1e-8) {
  const N = b.length;
  // Lipschitz constant L = largest eigenvalue of H (PSD). Cheap bound via Gershgorin:
  let L = 0;
  for (let i=0;i<N;i++){
    let rowSum = 0;
    for (let j=0;j<N;j++) rowSum += Math.abs(H[i][j]);
    L = Math.max(L, rowSum);
  }
  if (!isFinite(L) || L<=0) L = 1;

  // init at uniform simplex
  let y = new Array(N).fill(1/N);
  let w = y.slice();
  let t = 1;

  const grad = (x) => {
    // H x - b
    const g = new Array(N).fill(0);
    for (let i=0;i<N;i++){
      let acc = 0;
      const Hi = H[i];
      for (let j=0;j<N;j++) acc += Hi[j]*x[j];
      g[i] = acc - b[i];
    }
    return g;
  };

  let g = grad(y);
  for (let k=0;k<maxIter;k++){
    // step
    const step = 1.0 / L; // constant step; works well for PSD H
    const z = new Array(N);
    for (let i=0;i<N;i++) z[i] = y[i] - step * g[i];
    const wNext = projectSimplex(z);

    // Nesterov acceleration
    const tNext = 0.5*(1 + Math.sqrt(1 + 4*t*t));
    const yNext = wNext.map((wi, i) => wi + ((t - 1)/tNext)*(wi - w[i]));

    // check convergence by ||w_next - w||
    let diff = 0;
    for (let i=0;i<N;i++){ const d = wNext[i] - w[i]; diff += d*d; }
    if (diff <= tol*tol) return wNext;

    // iterate
    w = wNext; y = yNext; t = tNext; g = grad(y);
  }
  return w; // last iterate
}

/* === Exact constrained portfolios using the QP solver === */
// MVP: minimize 0.5 w^T Σ w
function mvp_true(Sigma) {
  const N = Sigma.length;
  const b = new Array(N).fill(0);
  return qpOnSimplex(Sigma, b);
}

// Gamma: maximize (μ - r_f 1)^T w - (γ/2) w^T Σ w  ⇔ minimize 0.5 (γΣ) w^T w - (μ - r_f 1)^T w
function gamma_true(mu, Sigma, rf, gamma) {
  const N = mu.length;
  const one = new Array(N).fill(1);
  const b = mu.map((m,i) => m - rf*one[i]);            // μ_excess
  const H = Sigma.map(row => row.map(v => v * gamma)); // γΣ
  return qpOnSimplex(H, b);
}

/* Efficient frontier via β-sweep: for each β >= 0 solve min 1/2 w^T Σ w - β μ^T w */
function frontier_true(mu, Sigma, rf, n=120) {
  const betas = [];
  // Sweep β on a log-ish grid to cover conservative → aggressive
  const betaMin = 1e-4, betaMax = 1e3;
  for (let k=0;k<n;k++){
    const t = k/(n-1);
    // smooth grid (exp on [betaMin,betaMax])
    const beta = betaMin * Math.pow(betaMax/betaMin, t);
    betas.push(beta);
  }
  const pts = [];
  const ws  = [];
  for (const beta of betas){
    const b = mu.map(m => beta*m);
    const w = qpOnSimplex(Sigma, b, 4000, 1e-8);
    const ret = Number(math.multiply(math.transpose(w), mu));
    const var_ = Number(math.multiply(math.transpose(w), math.multiply(Sigma, w)));
    pts.push({ r: ret, s: Math.sqrt(Math.max(var_,0)), w });
    ws.push(w);
  }
  // Pick tangency as frontier point with max Sharpe
  let bestIdx = 0, bestSharpe = -1e99;
  for (let i=0;i<pts.length;i++){
    const sh = (pts[i].r - rf) / Math.max(pts[i].s, 1e-12);
    if (sh > bestSharpe){ bestSharpe = sh; bestIdx = i; }
  }
  const tan = pts[bestIdx];
  return { pts, tan };
}

/* Stats */
function portfolioStats(w, mu, Sigma) {
  const wv = math.matrix(w);
  const ret = math.multiply(math.transpose(wv), mu);
  const var_ = math.multiply(math.transpose(wv), math.multiply(Sigma, wv));
  return { ret: Number(ret), vol: Math.sqrt(Math.max(Number(var_), 0)) };
}

/* === Unconstrained formulas (kept for "shorting allowed") === */
function optimalWeightsGivenGamma_unc(muExcess, Sigma, gamma) {
  const I = math.ones(muExcess.length)._data;
  const invS = math.inv(Sigma);
  const invS_mu = math.multiply(invS, muExcess);
  const invS_1  = math.multiply(invS, I);
  const A = math.multiply(math.transpose(I), invS_1);
  const B = math.multiply(math.transpose(I), invS_mu);
  const term1 = math.multiply(1/gamma, invS_mu);
  const term2 = math.multiply((gamma - B)/(gamma * A), invS_1);
  return toArray1D(math.add(term1, term2));
}
function mvp_unc(Sigma) {
  const I = math.ones(Sigma.length)._data;
  const invS = math.inv(Sigma);
  const invS1 = math.multiply(invS, I);
  const A = math.multiply(math.transpose(I), invS1);
  return toArray1D(math.divide(invS1, A));
}
function tangency_unc(mu, Sigma, rf) {
  const I = math.ones(mu.length)._data;
  const invS = math.inv(Sigma);
  const muEx = math.subtract(mu, math.multiply(rf, I));
  const num  = math.multiply(invS, muEx);
  const den  = math.multiply(math.transpose(I), num);
  const wT   = toArray1D(math.divide(num, den));
  const { ret, vol } = portfolioStats(wT, mu, Sigma);
  const sharpe = (ret - rf) / Math.max(vol, 1e-12);
  return { wT, ret, vol, sharpe };
}

/* === UI wiring === */
let weightsGamma = null, weightsTan = null, weightsMVP = null;

$('#btnCompute').addEventListener('click', async () => {
  try {
    statusEl.textContent = 'Parsing & computing…';
    const file = $('#fileInput').files[0];
    if (!file) throw new Error('Please choose a CSV file.');
    const text = await file.text();

    const freq = Number($('#freq').value);
    const rf = Number($('#rf').value) || 0;
    const gamma = Number($('#gamma').value);
    const nFrontier = Math.max(40, Number($('#nFrontier').value));
    const longOnly = $('#longOnly').checked;

    const { tickers, prices } = parseCSVToMatrix(text);
    if (prices.length < 3) throw new Error('Need at least 3 rows of prices.');
    const R = toReturns(prices, true); // log returns
    const { cov, mean: m } = covarianceMatrix(R);
    const { muA, sigA } = scaleAnnual(m, cov, freq);

    let wG, wM, tan, front;
    if (longOnly) {
      // === TRUE constrained (Goal B) ===
      wG = gamma_true(muA, sigA, rf, gamma);
      wM = mvp_true(sigA);
      const { pts, tan: tanPt } = frontier_true(muA, sigA, rf, nFrontier);
      front = pts;
      tan = { wT: tanPt.w, ret: tanPt.r, vol: tanPt.s, sharpe: (tanPt.r - rf)/Math.max(tanPt.s,1e-12) };
    } else {
      // === Unconstrained (closed-form) ===
      const muExcess = muA.map(u => u - rf);
      wG = optimalWeightsGivenGamma_unc(muExcess, sigA, gamma);
      wM = mvp_unc(sigA);
      const t = tangency_unc(muA, sigA, rf);
      tan = t;

      // Make a visual frontier by the analytic sweep (unconstrained)
      const pts = [];
      const N = muA.length;
      const I = math.ones(N)._data, invS = math.inv(sigA);
      const A = math.multiply(math.transpose(I), math.multiply(invS, I));
      const B = math.multiply(math.transpose(I), math.multiply(invS, muA));
      const C = math.multiply(math.transpose(muA), math.multiply(invS, muA));
      const D = A*C - B*B;
      const mu_mvp = B/A;
      let rLo = Math.min(mu_mvp, Math.min(...muA));
      let rHi = Math.max(Math.max(...muA), tan.ret);
      const spanUp = Math.max(rHi - mu_mvp, 1e-6);
      const spanDn = Math.max(mu_mvp - rLo, 1e-6);
      rHi = rHi + 0.35*spanUp; rLo = rLo - 0.35*spanDn;
      for (let k=0;k<nFrontier;k++){
        const r = rLo + (rHi - rLo)*k/(nFrontier-1);
        const alpha = (C - B*r)/D;
        const beta  = (A*r - B)/D;
        let w = math.multiply(invS, math.add(math.multiply(alpha, I), math.multiply(beta, muA)));
        w = toArray1D(w);
        const var_ = math.multiply(math.transpose(w), math.multiply(sigA, w));
        const ret  = math.multiply(math.transpose(w), muA);
        pts.push({ r: Number(ret), s: Math.sqrt(Math.max(Number(var_),0)), w });
      }
      front = pts;
    }

    const statsG = portfolioStats(wG, muA, sigA);

    // === CML (visual) ===
    const maxSigma = Math.max(tan.vol, statsG.vol, ...front.map(p => p.s)) * 1.05;
    const cmlPts = (function(){
      const slope = (tan.ret - rf) / Math.max(tan.vol, 1e-12);
      const pts = [];
      for (let i=0;i<100;i++){
        const x = (maxSigma * i)/(100-1);
        pts.push({ x, y: rf + slope * x });
      }
      return pts;
    })();

    // Save for downloads
    weightsGamma = tickers.map((t,i) => ({ Asset: t, Weight: wG[i] }));
    weightsTan   = tickers.map((t,i) => ({ Asset: t, Weight: tan.wT[i] }));
    weightsMVP   = tickers.map((t,i) => ({ Asset: t, Weight: wM[i] }));

    // Table: γ-weights
    const tbody = $('#weightsTable tbody');
    tbody.innerHTML = '';
    for (let i=0;i<tickers.length;i++){
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${tickers[i]}</td><td>${(wG[i]*100).toFixed(2)}%</td>`;
      tbody.appendChild(tr);
    }

    // Stats text
    $('#pfStats').textContent =
      `Optimal (γ=${gamma}${longOnly? ", long-only (QP)":""}):  E[μ]=${(statsG.ret*100).toFixed(2)}%  |  σ=${(statsG.vol*100).toFixed(2)}%  |  Sharpe≈${((statsG.ret - rf)/Math.max(statsG.vol,1e-9)).toFixed(2)}`;
    $('#tanStats').textContent =
      `Tangency${longOnly? " (true constrained)":""}:  E[μ]=${(tan.ret*100).toFixed(2)}%  |  σ=${(tan.vol*100).toFixed(2)}%  |  Sharpe=${tan.sharpe.toFixed(2)}  |  rf=${(rf*100).toFixed(2)}%`;

    // Plot
    const data = {
      labels: front.map(_=> ''),
      datasets: [
        { label: 'Efficient Frontier', data: front.map(p => ({ x: p.s, y: p.r })), showLine: true, pointRadius: 2 },
        { label: 'CML (through Tangency)', data: cmlPts, showLine: true, pointRadius: 0, borderDash: [6,4] },
        { label: 'Tangency Portfolio', data: [{ x: tan.vol, y: tan.ret }], pointRadius: 6 },
        { label: 'Your Portfolio (γ)', data: [{ x: statsG.vol, y: statsG.ret }], pointRadius: 6 }
      ]
    };
    const ctx = document.getElementById('frontierChart');
    if (chart) chart.destroy();
    chart = new Chart(ctx, {
      type: 'scatter',
      data,
      options: {
        animation: false,
        responsive: true,
        plugins: {
          legend: { position: 'top' },
          tooltip: {
            callbacks: {
              label: function(ctx){
                const x = ctx.raw.x, y = ctx.raw.y;
                return `σ=${(x*100).toFixed(2)}%, μ=${(y*100).toFixed(2)}%`;
              }
            }
          }
        },
        scales: {
          x: { title: { display: true, text: 'Volatility (σ, annualized)' } },
          y: { title: { display: true, text: 'Expected Return (μ, annualized)' } }
        }
      }
    });

    statusEl.innerHTML = `<span class="success">Done.</span> Loaded ${prices.length} rows × ${tickers.length} assets.`;
  } catch (e) {
    statusEl.innerHTML = `<span class="warn">Error:</span> ${e.message}`;
    console.error(e);
  }
});

/* CSV download helper */
function downloadCSV(rows, filename) {
  const header = 'Asset,Weight';
  const body   = rows.map(r => `${r.Asset},${r.Weight}`);
  const blob   = new Blob([[header, ...body].join('\n')], { type: 'text/csv;charset=utf-8;' });
  const url    = URL.createObjectURL(blob);
  const a      = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}

/* Download buttons */
document.getElementById('btnDownloadGamma').addEventListener('click', () => { if (weightsGamma) downloadCSV(weightsGamma, 'weights_gamma.csv'); });
document.getElementById('btnDownloadTan').addEventListener('click',   () => { if (weightsTan)   downloadCSV(weightsTan,   'weights_tangency.csv'); });
document.getElementById('btnDownloadMVP').addEventListener('click',   () => { if (weightsMVP)   downloadCSV(weightsMVP,   'weights_mvp.csv'); });
</script>
